from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from ..lava_job_submitter import LAVAJobSubmitter
    from .lava_job_definition import LAVAJobDefinition

from .lava_job_definition import NUMBER_OF_ATTEMPTS_LAVA_BOOT

# Use the same image that is being used for the hardware enablement and health-checks.
# They are pretty small (<100MB) and have all the tools we need to run LAVA, so it is a safe choice.
# You can find the Dockerfile here:
# https://gitlab.collabora.com/lava/health-check-docker/-/blob/main/Dockerfile
# And the registry here: https://gitlab.collabora.com/lava/health-check-docker/container_registry/
DOCKER_IMAGE = "registry.gitlab.collabora.com/lava/health-check-docker"


def fastboot_deploy_actions(job_definition: "LAVAJobDefinition", nfsrootfs) -> list[dict[str, Any]]:
    args = job_definition.job_submitter
    fastboot_deploy_nfs = {
        "timeout": {"minutes": 10},
        "to": "nfs",
        "nfsrootfs": nfsrootfs,
    }

    fastboot_deploy_prepare = {
        "timeout": {"minutes": 5},
        "to": "downloads",
        "os": "oe",
        "images": {
            "kernel": {
                "url": f"{args.kernel_url_prefix}/{args.kernel_image_name}",
            },
        },
        "postprocess": {
            "docker": {
                "image": DOCKER_IMAGE,
                "steps": [
                    f"cat Image.gz {args.dtb_filename}.dtb > Image.gz+dtb",
                    "mkbootimg --kernel Image.gz+dtb"
                    + ' --cmdline "root=/dev/nfs rw nfsroot=$NFS_SERVER_IP:$NFS_ROOTFS,tcp,hard rootwait ip=dhcp init=/init"'
                    + " --pagesize 4096 --base 0x80000000 -o boot.img",
                ],
            }
        },
    }

    fastboot_deploy = {
        "timeout": {"minutes": 2},
        "to": "fastboot",
        "docker": {
            "image": DOCKER_IMAGE,
        },
        "images": {
            "boot": {"url": "downloads://boot.img"},
        },
    }

    # URLs to our kernel rootfs to boot from, both generated by the base
    # container build
    job_definition.attach_kernel_and_dtb(fastboot_deploy_prepare["images"])

    return [{"deploy": d} for d in (fastboot_deploy_nfs, fastboot_deploy_prepare, fastboot_deploy)]


def tftp_deploy_actions(job_definition: "LAVAJobDefinition", nfsrootfs) -> list[dict[str, Any]]:
    args = job_definition.job_submitter
    tftp_deploy = {
        "timeout": {"minutes": 5},
        "to": "tftp",
        "os": "oe",
        "kernel": {
            "url": f"{args.kernel_url_prefix}/{args.kernel_image_name}",
        },
        "nfsrootfs": nfsrootfs,
    }
    job_definition.attach_kernel_and_dtb(tftp_deploy)

    return [{"deploy": d} for d in [tftp_deploy]]


def init_stage1_steps(args: "LAVAJobSubmitter") -> list[str]:
    run_steps = []
    # job execution script:
    #   - inline .gitlab-ci/common/init-stage1.sh
    #   - fetch and unpack per-pipeline build artifacts from build job
    #   - fetch and unpack per-job environment from lava-submit.sh
    #   - exec .gitlab-ci/common/init-stage2.sh

    with open(args.first_stage_init, "r") as init_sh:
        run_steps += [x.rstrip() for x in init_sh if not x.startswith("#") and x.rstrip()]
    # We cannot distribute the Adreno 660 shader firmware inside rootfs,
    # since the license isn't bundled inside the repository
    if args.device_type == "sm8350-hdk":
        run_steps.append(
            "curl -L --retry 4 -f --retry-all-errors --retry-delay 60 "
            + "https://github.com/allahjasif1990/hdk888-firmware/raw/main/a660_zap.mbn "
            + '-o "/lib/firmware/qcom/sm8350/a660_zap.mbn"'
        )

    return run_steps


def test_actions(job_definition: "LAVAJobDefinition") -> list[dict[str, Any]]:
    # skeleton test definition: only declaring each job as a single 'test'
    # since LAVA's test parsing is not useful to us
    args = job_definition.job_submitter
    run_steps = []
    test = {
        "timeout": {"minutes": args.job_timeout_min},
        "failure_retry": 1,
        "definitions": [
            {
                "name": "mesa",
                "from": "inline",
                "lava-signal": "kmsg",
                "path": "inline/mesa.yaml",
                "repository": {
                    "metadata": {
                        "name": "mesa",
                        "description": "Mesa test plan",
                        "os": ["oe"],
                        "scope": ["functional"],
                        "format": "Lava-Test Test Definition 1.0",
                    },
                    "run": {"steps": run_steps},
                },
            }
        ],
    }

    run_steps += init_stage1_steps(args)
    run_steps += job_definition.artifact_download_steps()

    run_steps += [
        f"mkdir -p {args.ci_project_dir}",
        f"curl {args.build_url} | tar --zstd -x -C {args.ci_project_dir}",
        # Sleep a bit to give time for bash to dump shell xtrace messages into
        # console which may cause interleaving with LAVA_SIGNAL_STARTTC in some
        # devices like a618.
        "sleep 1",
        # Putting CI_JOB name as the testcase name, it may help LAVA farm
        # maintainers with monitoring
        f"lava-test-case '{args.project_name}_{args.mesa_job_name}' --shell /init-stage2.sh",
    ]

    return [{"test": t} for t in [test]]


def tftp_boot_action(args: "LAVAJobSubmitter") -> dict[str, Any]:
    tftp_boot = {
        "failure_retry": NUMBER_OF_ATTEMPTS_LAVA_BOOT,
        "method": args.boot_method,
        "prompts": ["lava-shell:"],
        "commands": "nfs",
    }

    return tftp_boot


def fastboot_boot_action(args: "LAVAJobSubmitter") -> dict[str, Any]:
    fastboot_boot = {
        "timeout": {"minutes": 2},
        "docker": {"image": DOCKER_IMAGE},
        "failure_retry": NUMBER_OF_ATTEMPTS_LAVA_BOOT,
        "method": args.boot_method,
        "prompts": ["lava-shell:"],
        "commands": ["set_active a"],
    }

    return fastboot_boot


def generate_lava_yaml_payload(job_definition: "LAVAJobDefinition") -> dict[str, Any]:
    """
    Generates a YAML payload for submitting a LAVA job, based on the provided arguments.

    Args:
      args ("LAVAJobSubmitter"): The `args` parameter is an instance of the `LAVAJobSubmitter`
        class. It contains various properties and methods that are used to configure and submit a
        LAVA job.

    Returns:
        a dictionary containing the values generated by the `generate_metadata` function and the
        actions for the LAVA job submission.
    """
    job_submitter = job_definition.job_submitter
    values = job_definition.generate_metadata()
    nfsrootfs = {
        "url": f"{job_submitter.rootfs_url_prefix}/lava-rootfs.tar.zst",
        "compression": "zstd",
    }

    if job_submitter.boot_method == "fastboot":
        values["actions"] = [
            *fastboot_deploy_actions(job_definition, nfsrootfs),
            {"boot": fastboot_boot_action(job_submitter)},
        ]
    else:  # tftp
        values["actions"] = [
            *tftp_deploy_actions(job_definition, nfsrootfs),
            {"boot": tftp_boot_action(job_submitter)},
        ]

    values["actions"].extend(test_actions(job_definition))

    return values
