/*
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: MIT
 */

#ifndef VN_RING_H
#define VN_RING_H

#include "vn_common.h"

#include "vn_cs.h"

/**
 * A ring is a single-producer and single-consumer circular buffer.  The data
 * in the buffer are produced and consumed in order.  An externally-defined
 * mechanism is required for ring setup and notifications in both directions.
 * Notifications for new data from the producer are needed only when the
 * consumer is not actively polling, which is indicated by the ring status.
 *
 * For venus, the data are plain venus commands.  When a venus command is
 * consumed from the ring's perspective, there can still be ongoing CPU and/or
 * GPU works.  This is not an issue when the works generated by following
 * venus commands are correctly queued after the ongoing works.  There are
 * also venus commands that facilitate polling or waiting for ongoing works.
 */

/* the layout of a ring in a shmem */
struct vn_ring_layout {
   size_t head_offset;
   size_t tail_offset;
   size_t status_offset;

   size_t buffer_offset;
   size_t buffer_size;

   size_t extra_offset;
   size_t extra_size;

   size_t shmem_size;
};

static_assert(ATOMIC_INT_LOCK_FREE == 2 && sizeof(atomic_uint) == 4,
              "vn_ring_shared requires lock-free 32-bit atomic_uint");

/* pointers to a ring in a BO */
struct vn_ring_shared {
   const volatile atomic_uint *head;
   volatile atomic_uint *tail;
   volatile atomic_uint *status;
   void *buffer;
   void *extra;
};

struct vn_ring {
   uint64_t id;
   struct vn_instance *instance;
   struct vn_renderer_shmem *shmem;

   uint32_t buffer_size;
   uint32_t buffer_mask;

   struct vn_ring_shared shared;
   uint32_t cur;

   /* This mutex ensures below:
    * - atomic of ring submission
    * - reply shmem resource set and ring submission are paired
    */
   mtx_t mutex;

   /* used for indirect submission of large command (non-VkCommandBuffer) */
   struct vn_cs_encoder upload;

   struct list_head submits;
   struct list_head free_submits;
};

void
vn_ring_get_layout(size_t buf_size,
                   size_t extra_size,
                   struct vn_ring_layout *layout);

struct vn_ring *
vn_ring_create(struct vn_instance *instance,
               const struct vn_ring_layout *layout);

void
vn_ring_destroy(struct vn_ring *ring);

uint32_t
vn_ring_load_status(const struct vn_ring *ring);

void
vn_ring_unset_status_bits(struct vn_ring *ring, uint32_t mask);

bool
vn_ring_get_seqno_status(struct vn_ring *ring, uint32_t seqno);

/* forward declaration before updating protocol to submit via ring */
struct vn_instance_submit_command;

void
vn_ring_submit_command(struct vn_ring *ring,
                       struct vn_instance_submit_command *submit);

VkResult
vn_ring_submit_command_simple(struct vn_ring *ring,
                              const struct vn_cs_encoder *cs);

#endif /* VN_RING_H */
